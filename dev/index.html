<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction · Jaynes.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/favicon.ico" rel="icon" type="image/x-icon"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.png" alt="Jaynes.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Jaynes.jl</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href="index.html">Introduction</a></li><li><a class="tocitem" href="architecture.html">Implementation architecture</a></li><li><a class="tocitem" href="contextual_DSLs.html">Contextual domain-specific languages</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="index.html">Introduction</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="index.html">Introduction</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/femtomc/Jaynes.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><p>There are many active probabilistic programming frameworks in the Julia ecosystem (see <a href="related_work.html">Related Work</a>) - the ecosystem is one of the richest sources of probabilistic programming research in any language. Frameworks tend to differentiate themselves based upon what model class they efficiently express (<a href="https://github.com/willtebbutt/Stheno.jl">Stheno</a> for example allows for convenient expression of Gaussian processes). Other frameworks support universal probabilistic programming with sample-based methods, and have optimized features which allow the efficient composition/expression of inference queries (e.g. <a href="https://turing.ml/dev/">Turing</a> and <a href="https://github.com/probcomp/Gen.jl">Gen</a>). Jaynes sits within this latter camp - it is strongly influenced by Turing and Gen, but more closely resembles a system like <a href="https://github.com/FluxML/Zygote.jl">Zygote</a>. The full-scope Jaynes system will allow you to express the same things you might express in these other systems - but the long term research goals may deviate slightly from these other libraries. In this section, I will discuss a few of the long term goals.</p><hr/><h3 id="Graphical-model-DSL-1"><a class="docs-heading-anchor" href="#Graphical-model-DSL-1">Graphical model DSL</a><a class="docs-heading-anchor-permalink" href="#Graphical-model-DSL-1" title="Permalink"></a></h3><p>One of the research goals of Jaynes to identify <em>composable interfaces</em> for allowing users to express static graphical models alongside dynamic sample-based models. This has previously been a difficult challenge - the representations which each class of probabilistic programming system utilizes is very different. Universal probabilistic programming systems have typically relied on sample-based inference, where the main representation is a structured form of an execution trace. In contrast, graphical model systems reason explicitly about distributions and thus require an explicit graph representation of how random variates depend on one another.</p><p>A priori, there is no reason why these representations can&#39;t be combined in some way. The difficulty lies in deciding how to switch between representations when a program is amenable to both, as well as how the different representations will communicate across inference interfaces. For example, consider performing belief propagation on a model which supports both discrete distributions and function call sites for probabilistic programs which required a sample-based tracing mechanism for interpretation. To enable inference routines to operate on this &quot;call graph&quot; style representation, we have to construct and reason about the representation separately from the runtime of each program.</p><h3 id="Density-compilation-1"><a class="docs-heading-anchor" href="#Density-compilation-1">Density compilation</a><a class="docs-heading-anchor-permalink" href="#Density-compilation-1" title="Permalink"></a></h3><p>TODO.</p><h3 id="Automatic-inference-compilation-1"><a class="docs-heading-anchor" href="#Automatic-inference-compilation-1">Automatic inference compilation</a><a class="docs-heading-anchor-permalink" href="#Automatic-inference-compilation-1" title="Permalink"></a></h3><p>Jaynes already provides (rudimentary) support for gradient-based learning in probabilistic programs. Jaynes also provides a simple interface to construct and use <a href="https://arxiv.org/abs/1610.09900"><em>inference compilers</em></a>. The library function <code>inference_compilation</code> provides access to the inference compiler context. The result of inference compilation is a trained inference compiler context which can be used to generate traces for the posterior conditioned on observations.</p><pre><code class="language-julia">function foo1()
    x = rand(:x, Normal, (3.0, 10.0))
    y = rand(:y, Normal, (x + 15.0, 0.3))
    return y
end

ctx = inference_compilation(foo1, (), :y; batch_size = 256, epochs = 100)
obs = constraints([(:y, 10.0)])
ctx, tr, score = trace(ctx, obs)</code></pre><p>The user must provide a target observation address to the <code>inference_compilation</code> call. This allows the inference compiler to construct an observation-specific head during training.</p><p>This inference method is not yet fully tested - but you can take a peek in the <code>src</code> to see how it will eventually be stabilized. One of the long term goals of Jaynes is to provide a backend for inference compilation of arbitary programs. If a user does not specify the choice map structure of the program, the addresses will be automatically filled in, with enough reference metadata to allow the user to locate the <code>rand</code> call in the original program. Of course, it is always preferable to structure your own choice map space - this feature is intended to allow programs with untraced <code>rand</code> calls to utilize a useful (but possibly limited) form of inference.</p><h3 id="Black-box-extensions-1"><a class="docs-heading-anchor" href="#Black-box-extensions-1">Black-box extensions</a><a class="docs-heading-anchor-permalink" href="#Black-box-extensions-1" title="Permalink"></a></h3><p><em>Jaynes</em> is equipped with the ability to extend the tracing interface to black-box code. This is naturally facilitated by the metaprogramming capabilities of <code>Cassette</code>. The primary usage of this extension is to define new <code>logpdf</code> method definitions for code which may contain sources of randomness which are not annotated with addresses and/or where inspection by the tracing mechanism can be safely abstracted over. Thus, <code>@primitive</code> defines a contract between the user and the tracer - we assume that what you&#39;re doing is correct and we&#39;re not going to check you on it!</p><p>The following example shows how this extension mechanism works.</p><pre><code class="language-julia">function foo(y::Float64)
    # Untraced randomness.
    y = rand(Normal(0.5, 3.0))
    return y
end

@primitive function logpdf(fn::typeof(foo), args::Tuple{Float64}, y::Float64)
    if y &lt; 1.0
        log(1) 
    else
        -Inf
    end
end

function bar(z::Float64)
    y = rand(:y, foo, (z, ))
    return y
end

ctx = Generate(Trace())
ret = trace(ctx, bar, (0.3, ))
println(ctx.metadata.tr)

#  __________________________________
#
#               Playback
#
# y
#          val  = 2.8607525733342767
#
#  __________________________________
#
# score : 0.0
#
#  __________________________________
</code></pre><p><code>@primitive</code> requires that the user define a <code>logpdf</code> definition for the call. This expands into <code>overdub</code> method definitions for the tracer which automatically work with all the core library context/metadata dispatch. The signature for <code>logpdf</code> should match the following type specification:</p><pre><code class="language-julia">logpdf(::typeof(your_func), ::Tuple, ::T)</code></pre><p>where <code>T</code> is the return type of <code>your_func</code>. </p><p>Note that, if your defined <code>logpdf</code> is differentiable - gradients will automatically be derived for use in <code>Gradient</code> learning contexts as long as <code>Zygote</code> can differentiate through it. This can be used to e.g. train neural networks in <code>Gradient</code> contexts where the loss is wrapped in the <code>logpdf</code>/<code>@primitive</code> interface mechanism.</p><p>The extension mechanism <em>does not</em> check if the user-defined <code>logpdf</code> is valid. This mechanism also overrides the normal fallback (i.e. tracing into calls) for any function for which the mechanism is used to write a <code>logpdf</code> - this means that if you write a <code>logpdf</code> using this mechanism for a call and there <em>is</em> addressed randomness in the call, it will be ignored by the tracer.</p><hr/><h3 id="Summary-1"><a class="docs-heading-anchor" href="#Summary-1">Summary</a><a class="docs-heading-anchor-permalink" href="#Summary-1" title="Permalink"></a></h3><p>To facilitate these research goals, Jaynes is designed as a type of compiler plugin. In contrast to existing frameworks, Jaynes does not require the use of specialized macros to denote where the modeling language begins and ends. The use of macros to denote a language barrier has a number of positive advantages from a user-facing perspective, but some disadvantages related to composability. As an opinion, I believe that a general framework for expressing probabilistic programs should mimic the philosophy of <em>differentiable programming</em>. The compiler plugin backend should prevent users from writing programs which are &quot;not valid&quot; (either as a static analysis or a runtime error) but should otherwise get out of the way of the user. Any macros present in the Jaynes library extend the core functionality or provide convenient access to code generation for use by a user - but are not required for modeling and inference.</p><p>Because Jaynes is a compiler plugin, it is highly configurable. The goal of the core package is to implement a set of &quot;sensible defaults&quot; for common use, while allowing the implementation of other DSLs, custom inference algorithms, custom representations, etc on top. In this philosophy, Jaynes follows a path first laid out by Gen and Zygote...with a few twists.</p><p>Bon appétit!</p></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="architecture.html">Implementation architecture »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 9 June 2020 20:39">Tuesday 9 June 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
