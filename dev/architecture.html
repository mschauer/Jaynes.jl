<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Implementation architecture · Jaynes.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/favicon.ico" rel="icon" type="image/x-icon"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.png" alt="Jaynes.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Jaynes.jl</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li class="is-active"><a class="tocitem" href="architecture.html">Implementation architecture</a></li><li><a class="tocitem" href="contextual_DSLs.html">Contextual domain-specific languages</a></li><li><a class="tocitem" href="gradients.html">Differentiable programming</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="architecture.html">Implementation architecture</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="architecture.html">Implementation architecture</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/femtomc/Jaynes.jl/blob/master/docs/src/architecture.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><p>This is a library which implements probabilistic programming by intercepting calls to <code>rand</code> and interpreting them according to a user-provided context. The interception is automatic through the execution of Julia code, as the interception is provided by compiler injection into an intermediate representation of code (lowered code) using a package called <a href="https://github.com/jrevels/Cassette.jl">Cassette</a>.</p><p>Cassette is a very powerful package, but it&#39;s also very subtle and easy to cause deep issues in the compilation pipeline. Here, I&#39;m not doing anything too crazy with, say, composition of contexts or compiler pass injection (yet). The basic idea is that you may have some code</p><pre><code class="language-julia">function foo(x::Float64)
    y = rand(:y, Normal, (x, 1.0))
    return y
end</code></pre><p>which you want to interpret in a probabilistic programming context. The lowered code looks like this:</p><pre><code class="language-julia">1 ─ %1 = Core.tuple(x, 1.0)
│        y = Main.rand(:y, Main.Normal, %1)
└──      return y</code></pre><p>After we intercept, the code looks like this:</p><pre><code class="language-julia">1 ─      #self# = Core.getfield(##overdub_arguments#254, 1)
│        x = Core.getfield(##overdub_arguments#254, 2)
│        Cassette.prehook(##overdub_context#253, Core.tuple, x, 1.0)
│   %4 = Cassette.overdub(##overdub_context#253, Core.tuple, x, 1.0)
│        Cassette.posthook(##overdub_context#253, %4, Core.tuple, x, 1.0)
│   %6 = %4
│        Cassette.prehook(##overdub_context#253, Main.rand, :y, Main.Normal, %6)
│   %8 = Cassette.overdub(##overdub_context#253, Main.rand, :y, Main.Normal, %6)
│        Cassette.posthook(##overdub_context#253, %8, Main.rand, :y, Main.Normal, %6)
│        y = %8
│   @ REPL[1]:3 within `foo&#39;
└──      return y</code></pre><p>notice that every method invocation has been wrapped in a special function (either <code>prehook</code>, <code>overdub</code>, or <code>posthook</code>) which accepts a special structure as first argument (a <em>context</em>). For this conversation, we won&#39;t use the special <code>prehook</code> or <code>posthook</code> points of access...</p><pre><code class="language-julia">1 ─      #self# = Core.getfield(##overdub_arguments#254, 1)
│        x = Core.getfield(##overdub_arguments#254, 2)
│   %4 = Cassette.overdub(##overdub_context#253, Core.tuple, x, 1.0)
│   %6 = %4
│   %8 = Cassette.overdub(##overdub_context#253, Main.rand, :y, Main.Normal, %6)
│        y = %8
│   @ REPL[1]:3 within `foo&#39;
└──      return y</code></pre><p>so we&#39;ll just discuss <code>overdub</code>. Now, a structured form for the <code>overdub</code> context allows us to record probabilistic statements to a trace. What is a <em>context</em>?</p><pre><code class="language-julia">Context{N&lt;:Cassette.AbstractContextName,
        M&lt;:Any,
        P&lt;:Cassette.AbstractPass,
        T&lt;:Union{Nothing,Cassette.Tag},
        B&lt;:Union{Nothing,Cassette.BindingMetaDictCache},
        H&lt;:Union{Nothing,Cassette.DisableHooks}}</code></pre><p>where <code>M</code> is <em>metadata</em>. We use a structured trace as metadata</p><pre><code class="language-julia">mutable struct UnconstrainedGenerateMeta &lt;: Meta
    tr::Trace
    stack::Vector{Address}
    UnconstrainedGenerateMeta(tr::Trace) = new(tr, Address[])
end</code></pre><p>and then, with <code>overdub</code>, we intercept <code>rand</code> calls and store the correct location, value, and score in the trace inside the meta.</p><pre><code class="language-julia">function Cassette.overdub(ctx::TraceCtx{M}, 
                          call::typeof(rand), 
                          addr::T, 
                          dist::Type,
                          args) where {N, 
                                       M &lt;: UnconstrainedGenerateMeta, 
                                       T &lt;: Address}
    # Check stack.
    !isempty(ctx.metadata.stack) &amp;&amp; begin
        push!(ctx.metadata.stack, addr)
        addr = foldr((x, y) -&gt; x =&gt; y, ctx.metadata.stack)
        pop!(ctx.metadata.stack)
    end

    # Check for support errors.
    haskey(ctx.metadata.tr.chm, addr) &amp;&amp; error(&quot;AddressError: each address within a rand call must be unique. Found duplicate $(addr).&quot;)

    d = dist(args...)
    sample = rand(d)
    score = logpdf(d, sample)
    ctx.metadata.tr.chm[addr] = Choice(sample, score)
    return sample
end</code></pre><p>We also keep a stack around to handle hierarchical addressing inside function calls. The stack is essentially a lightweight call stack which tracks where we are while tracing. This lets us get the addressing correct, without doing too much work.</p><p>Different forms of metadata structure allow us to implement sampling-based inference algorithms efficiently. A <code>ProposalMeta</code> comes with its own <code>overdub</code> dispatch which minimizes calls during a proposal sampling routine:</p><pre><code class="language-julia">@inline function Cassette.overdub(ctx::TraceCtx{M}, 
                                  call::typeof(rand), 
                                  addr::T, 
                                  dist::Type,
                                  args) where {M &lt;: ProposalMeta, 
                                               T &lt;: Address}
    # Check stack.
    !isempty(ctx.metadata.stack) &amp;&amp; begin
        push!(ctx.metadata.stack, addr)
        addr = foldr((x, y) -&gt; x =&gt; y, ctx.metadata.stack)
        pop!(ctx.metadata.stack)
    end

    # Check for support errors.
    addr in ctx.metadata.visited &amp;&amp; error(&quot;AddressError: each address within a rand call must be unique. Found duplicate $(addr).&quot;)

    d = dist(args...)
    sample = rand(d)
    score = logpdf(d, sample)
    ctx.metadata.tr.chm[addr] = Choice(sample, score)
    ctx.metadata.tr.score += score
    push!(ctx.metadata.visited, addr)
    return sample

end</code></pre><p>To express inference algorithms, we can mix <code>overdub</code> dispatch on contexts with certain subtypes of <code>Meta</code>. Contexts are re-used during iterative algorithms - the dominant form of allocation is new-ing up blank <code>Trace</code> instances for tracing.</p><pre><code class="language-julia">function importance_sampling(model::Function, 
                             args::Tuple,
                             proposal::Function,
                             proposal_args::Tuple,
                             observations::Dict{Address, T},
                             num_samples::Int) where T
    trs = Vector{Trace}(undef, num_samples)
    lws = Vector{Float64}(undef, num_samples)
    prop_ctx = disablehooks(TraceCtx(metadata = ProposalMeta(Trace())))
    model_ctx = disablehooks(TraceCtx(metadata = GenerateMeta(Trace(), observations)))
    for i in 1:num_samples
        # Propose.
        if isempty(proposal_args)
            Cassette.overdub(prop_ctx, proposal)
        else
            Cassette.overdub(prop_ctx, proposal, proposal_args...)
        end

        # Merge proposals and observations.
        prop_score = prop_ctx.metadata.tr.score
        prop_chm = prop_ctx.metadata.tr.chm
        constraints = merge(observations, prop_chm)
        model_ctx.metadata.constraints = constraints

        # Generate.
        if isempty(args)
            res = Cassette.overdub(model_ctx, model)
        else
            res = Cassette.overdub(model_ctx, model, args...)
        end

        # Track score.
        model_ctx.metadata.tr.func = model
        model_ctx.metadata.tr.args = args
        model_ctx.metadata.tr.retval = res
        lws[i] = model_ctx.metadata.tr.score - prop_score
        trs[i] = model_ctx.metadata.tr

        # Reset.
        reset_keep_constraints!(model_ctx.metadata)
        reset_keep_constraints!(prop_ctx.metadata)
    end
    ltw = lse(lws)
    lmle = ltw - log(num_samples)
    lnw = lws .- ltw
    return trs, lnw, lmle
end</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="index.html">« Introduction</a><a class="docs-footer-nextpage" href="contextual_DSLs.html">Contextual domain-specific languages »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 15 June 2020 16:58">Monday 15 June 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
